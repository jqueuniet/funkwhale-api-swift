//
// Metadata20.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

@available(*, deprecated, renamed: "FunkwhaleClientAPI.Metadata20")
public typealias Metadata20 = FunkwhaleClientAPI.Metadata20

extension FunkwhaleClientAPI {

public struct Metadata20: Codable, JSONEncodable, Hashable {

    public var actorId: String
    public var _private: Bool
    public var shortDescription: String
    public var longDescription: String
    public var contactEmail: String
    public var nodeName: String
    public var banner: String
    public var defaultUploadQuota: Int
    public var supportedUploadExtensions: [String]
    public var allowList: AllowListStat
    public var funkwhaleSupportMessageEnabled: Bool
    public var instanceSupportMessage: String
    public var usage: MetadataUsage?
    public var library: NodeInfoLibrary
    public var reportTypes: [ReportType]
    public var endpoints: Endpoints
    public var rules: String
    public var terms: String

    public init(actorId: String, _private: Bool, shortDescription: String, longDescription: String, contactEmail: String, nodeName: String, banner: String, defaultUploadQuota: Int, supportedUploadExtensions: [String], allowList: AllowListStat, funkwhaleSupportMessageEnabled: Bool, instanceSupportMessage: String, usage: MetadataUsage? = nil, library: NodeInfoLibrary, reportTypes: [ReportType], endpoints: Endpoints, rules: String, terms: String) {
        self.actorId = actorId
        self._private = _private
        self.shortDescription = shortDescription
        self.longDescription = longDescription
        self.contactEmail = contactEmail
        self.nodeName = nodeName
        self.banner = banner
        self.defaultUploadQuota = defaultUploadQuota
        self.supportedUploadExtensions = supportedUploadExtensions
        self.allowList = allowList
        self.funkwhaleSupportMessageEnabled = funkwhaleSupportMessageEnabled
        self.instanceSupportMessage = instanceSupportMessage
        self.usage = usage
        self.library = library
        self.reportTypes = reportTypes
        self.endpoints = endpoints
        self.rules = rules
        self.terms = terms
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case actorId
        case _private = "private"
        case shortDescription
        case longDescription
        case contactEmail
        case nodeName
        case banner
        case defaultUploadQuota
        case supportedUploadExtensions
        case allowList
        case funkwhaleSupportMessageEnabled
        case instanceSupportMessage
        case usage
        case library
        case reportTypes
        case endpoints
        case rules
        case terms
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(actorId, forKey: .actorId)
        try container.encode(_private, forKey: ._private)
        try container.encode(shortDescription, forKey: .shortDescription)
        try container.encode(longDescription, forKey: .longDescription)
        try container.encode(contactEmail, forKey: .contactEmail)
        try container.encode(nodeName, forKey: .nodeName)
        try container.encode(banner, forKey: .banner)
        try container.encode(defaultUploadQuota, forKey: .defaultUploadQuota)
        try container.encode(supportedUploadExtensions, forKey: .supportedUploadExtensions)
        try container.encode(allowList, forKey: .allowList)
        try container.encode(funkwhaleSupportMessageEnabled, forKey: .funkwhaleSupportMessageEnabled)
        try container.encode(instanceSupportMessage, forKey: .instanceSupportMessage)
        try container.encodeIfPresent(usage, forKey: .usage)
        try container.encode(library, forKey: .library)
        try container.encode(reportTypes, forKey: .reportTypes)
        try container.encode(endpoints, forKey: .endpoints)
        try container.encode(rules, forKey: .rules)
        try container.encode(terms, forKey: .terms)
    }
}

}
